#!/usr/bin/env python

import shutil
import time
import os
import stat
import errno
import sys
#import sqlite3

SPLITFS_VERSION = '0.0.1'
import fuse
fuse.fuse_python_api = (0, 2)

#log_file = sys.stdout
#log_file = sys.stderr
log_file = open('/tmp/splitfs.log', 'a')

def debug(text):
    log_file.write(text)
    log_file.write('\n')
    log_file.flush()

class SplitFS(fuse.Stat):
  def __init__(self):
      self.st_mode = stat.S_IFDIR | 0755
      self.st_ino = 0
      self.st_dev = 0
      self.st_nlink = 2
      self.st_uid = 0
      self.st_gid = 0
      self.st_size = 8092
      self.st_atime = 42
      self.st_mtime = 42
      self.st_ctime = 42

def make_file_class(file_system):
    class SplitFile(object):
        direct_io = False
        keep_split = False

        def __init__(self, path, flags, *mode):
            self.path = path
            self.pp = file_system._physical_path(self.path)
            print('>> file<%s>.open(flags=%d, mode=%s)' % (self.pp, flags, mode))

            if len(mode) > 0:
                self.f = os.open(self.pp, flags, mode[0])
            else:
                self.f = os.open(self.pp, flags)

            inode_id = os.stat(self.pp).st_ino
            debug('test')
            #self.data_split = FileDataSplit(file_system.split_db, file_system.split, path, flags, inode_id)

        def read(self, size, offset):
            try:
                buf = self.data_split.read(size, offset)
            except SplitMiss:
                os.lseek(self.f, offset, os.SEEK_SET)
                buf = os.read(self.f, size)
                self.data_split.update(buf, offset, os.read(self.f, 1)=='')
            return buf

        def write(self, buf, offset):
#            print('>> file<%s>.write(len(buf)=%d, offset=%s)' % (self.path, len(buf), offset))
            os.lseek(self.f, offset, os.SEEK_SET)
            os.write(self.f, buf)

            end = os.stat(self.pp).st_size
            self.data_split.update(buf, offset, offset + len(buf) == end)

            return len(buf)


        def release(self, flags):
            print('>> file<%s>.release()' % self.path)
            os.close(self.f)
            self.data_split.close()
            self.data_split.report()
            return 0

        def flush(self):
            os.fsync(self.f)

    return SplitFile

class SplitFS(fuse.Fuse):
    def __init__(self, *args, **kwargs):
        fuse.Fuse.__init__(self, *args, **kwargs)
        #super(SplitFS, self).__init__(*args, **kwargs)
        self.file_class = make_file_class(self)

    def _physical_path(self, path):
        phys_path = os.path.join(self.target, path.lstrip('/'))
        return phys_path

    def getattr(self, path):
        debug("TEST");
        try:
           pp = self._physical_path(path)
           # Hide non-public files (except root)
           return os.lstat(pp)
        except Exception, e:
           debug(str(e))
           raise e

    def readdir(self, path, offset):
        debug("TEST");
        phys_path = self._physical_path(path).rstrip('/') + '/'
        for r in ('..', '.'):
            yield fuse.Direntry(r)
        for r in os.listdir(phys_path):
            virt_path = r
            debug('readdir yield: ' + virt_path)
            yield fuse.Direntry(virt_path)

    def readlink(self, path):
#        print('>> readlink("%s")' % path)
        phys_resolved = os.readlink(self._physical_path(path))
        debug('   resolves to physical "%s"' % phys_resolved)
        return phys_resolved


    def unlink(self, path):
#        print('>> unlink("%s")' % path)
        os.remove(self._physical_path(path))
        try:
            FileDataSplit(self.split_db, self.split, path).unlink()
        except:
            pass
        return 0

    # Note: utime is deprecated in favour of utimens.
    def utime(self, path, times):
        """
        Sets the access and modification times on a file.
        times: (atime, mtime) pair. Both ints, in seconds since epoch.
        Deprecated in favour of utimens.
        """
        debug('>> utime("%s", %s)' % (path, times))
        os.utime(self._physical_path(path), times)
        return 0

    def access(self, path, flags):
        path = self._physical_path(path)
        os.access(path, flags)

    def mkdir(self, path, mode):
        print('>> mkdir("%s")' % path)
        path = self._physical_path(path)
        os.mkdir(path, mode)

    def rmdir(self, path):
        print('>> rmdir("%s")' % path)
        os.rmdir( self._physical_path(path) )
        FileDataSplit.rmdir(self.split, path)

    def symlink(self, target, name):
        print('>> symlink("%s", "%s")' % (target, name))
        os.symlink(self._physical_path(target), self._physical_path(name))

    def link(self, target, name):
        print('>> link(%s, %s)' % (target, name))
        os.link(self._physical_path(target), self._physical_path(name))
        FileDataSplit(self.split_db, self.split, name, None, os.stat(self._physical_path(name)).st_ino)

    def rename(self, old_name, new_name):
        print('>> rename(%s, %s)' % (old_name, new_name))
        os.rename(self._physical_path(old_name),
                  self._physical_path(new_name))
        try:
            fdc = FileDataSplit(self.split_db, self.split, old_name)
            fdc.rename(new_name)
        except :
            pass

    def chmod(self, path, mode):
        os.chmod(self._physical_path(path), mode)

    def chown(self, path, user, group):
        os.chown(self._physical_path(path), user, group)

    def truncate(self, path, len):
        f = open(self._physical_path(path), "a")
        f.truncate(len)
        f.close()
        try:
            split = FileDataSplit(self.split_db, self.split, path)
            split.open()
            split.truncate(len)
            split.close()
        except:
            pass

def main():
    usage = '%prog MOUNTPOINT -o target=SOURCE [options]'
    sfs = SplitFS(version = 'SplitFS %s' % SPLITFS_VERSION,
                  usage = usage,
                  dash_s_do = 'setsingle')

    sfs.parser.add_option(
        mountopt = "target", metavar="PATH",
        default = None,
        help = "Path to be splitted / unsplitted")

    sfs.parse(values = sfs, errex = 1)
    sfs.target = os.path.abspath(sfs.target)
    sfs.multithreaded = 0
    #sfs.split_db = create_db(split_dir)

    print 'Setting up SplitFS %s ...' % SPLITFS_VERSION
    print '  Target       : %s' % sfs.target
    print '  Mount Point  : %s' % os.path.abspath(sfs.fuse_args.mountpoint)
    print
    print 'Unmount through:'
    print '  fusermount -u %s' % sfs.fuse_args.mountpoint
    print
    print 'Done.'
    sfs.main()
    return 0


if __name__ == '__main__':
    main()
